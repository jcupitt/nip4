/* make an image of size x by y whose pixels are their coordinates.
 */
makexy x y = vips_xyz [] (to_real x) (to_real y);

/* make an image with the specified properties ... pixel is (eg.)
 * Vector [0, 0, 0], or 12. If coding == labq, we ignore bands, format and
 * type, generate a 3 band float image, and lab2labq it before handing it
 * back.
 */
image_new options w h
    = embed 1 0 0 w h image'''
{
    defaults = get_option options [
        $format => Image_format.UCHAR,
        $bands => 1,
        $coding => Image_coding.NOCODING,
        $interpretation => Image_interpretation.B_W,
        $xres => 0,
        $yres => 0,
        $xoffset => 0,
        $yoffset => 0,
        $pixel => 0
    ];

    coding = defaults $coding;
    format
        = Image_format.FLOAT, coding == Image_coding.LABPACK
        = defaults $format;
    bands
        = 3, coding == Image_coding.LABPACK
        = defaults $bands;
    interpretation
        = Image_interpretation.LAB, coding == Image_coding.LABPACK
        = defaults $interpretation;
    xres = defaults $xres;
    yres = defaults $yres;
    xoffset = defaults $xoffset;
    yoffset = defaults $yoffset;
    pixel = defaults $pixel;

    image = vips_black [$bands => to_real bands] 1 1 + pixel;
    image' = vips_cast [] image format;
    image''
        = vips_Lab2LabQ [] image', coding == Image_coding.LABPACK
        = image';
    image''' = copy [
        $interpretation => interpretation,
        $xres => xres,
        $yres => yres,
        $xoffset => xoffset,
        $yoffset => yoffset
    ] image'';
}

image_new_from_image options image
    = image_new options'
{
    // earlier options override later options, so we just append the image
    // properties to the option set
    options' = options ++ [
            $bands => get_bands image,
            $format => get_format image,
            $coding => get_coding image,
            $interpretation => get_interpretation image,
            $xoffset => get_xoffset image,
            $yoffset => get_yoffset image,
            $xres => get_xres image,
            $yres => get_yres image
    ];
}

/* generate a slice of LAB space size x size pixels for L* == l
 */
lab_slice size l
    = set_header $interpretation $lab im
{
    L = image_new [
        $format => Image_format.FLOAT,
        $interpretation => Image_type.B_W,
        $pixel => l
    ] size size;

    A1 = vips_grey [] (to_real size) (to_real size);
    A2 = A1 * 256 - 128;
    A3 = rot90 A2;
    im = copy [$xoffset => size / 2, $yoffset => size / 2] (L ++ A2 ++ A3);
}

/* Look at Image, try to make a Colour (failing that, a Vector) which is white
 * for that image type.
 */
image_white im
    = colour_transform_to type white_lab,
        bands == 3 && coding == Image_coding.NOCODING &&
        colour_spaces.present 1 type
    = white_lab,
        coding == Image_coding.LABPACK
    = Vector (replicate bands (max_value.lookup 1 0 format))
{
    bands = im.bands;
    type = im.type;
    format = im.format;
    coding = im.coding;
    colour_spaces = Image_type.colour_spaces;

    // white as LAB
    white_lab = Colour "Lab" [100, 0, 0];

    // maximum value for this numeric type
    max_value = Table [
        [255, Image_format.DPCOMPLEX],
        [255, Image_format.DOUBLE],
        [255, Image_format.COMPLEX],
        [255, Image_format.FLOAT],
        [2 ** 31 - 1, Image_format.INT],
        [2 ** 32 - 1, Image_format.UINT],
        [2 ** 15 - 1, Image_format.SHORT],
        [2 ** 16 - 1, Image_format.USHORT],
        [2 ** 7 - 1, Image_format.CHAR],
        [2 ** 8 - 1, Image_format.UCHAR]
    ];
}

/* Make a seperable gaussian mask.
 */
matrix_gaussian_blur radius
        = im_gauss_imask_sep (radius / 3) 0.2;

/* Make a seperable square mask.
 */
matrix_blur radius
        = Matrix_con (sum mask_sq_line) 0 [mask_sq_line]
{
        mask_sq_line = replicate (2 * radius - 1) 1;
}

/* Make a colour from a temperature.
 */
colour_from_temp T
    = error (_ "T out of range"), T < 1667 || T > 25000
    = Colour "Yxy" [50, x, y]
{
    // Kim et all approximation
    // see eg. http://en.wikipedia.org/wiki/Planckian_locus#Approximation
    x
        = -0.2661239 * 10 ** 9 / T ** 3 - 0.2343580 * 10 ** 6 / T ** 2 +
            0.8776956 * 10 ** 3 / T + 0.179910, T < 4000
        = -3.0258469 * 10 ** 9 / T ** 3 + 2.1070379 * 10 ** 6 / T ** 2 +
            0.2226347 * 10 ** 3 / T + 0.240390;

    y
        = -1.1063814 * x ** 3 - 1.34811020 * x ** 2 +
            2.18555832 * x - 0.20219638, T < 2222
        = -0.9549476 * x ** 3 - 1.37418593 * x ** 2 +
            2.09137015 * x - 0.16748867, T < 4000
        =  3.0817580 * x ** 3 - 5.87338670 * x ** 2 +
            3.75112997 * x - 0.37001483;
}

temp_from_colour z
    = T
{
    c = colour_transform_to Image_type.YXY (to_colour z);
    x = c.value?1;
    y = c.value?2;

    // McCamy's approximation, see eg.
    // http://en.wikipedia.org/wiki/Color_temperature#Approximation

    xe = 0.332;
    ye = 0.1858;
    n = (x - xe) / (y - ye);
    T = -449 * n ** 3 + 3525 * n ** 2 - 6823.3 * n + 5520.33;
}

